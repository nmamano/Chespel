This file tries to give some formalism to the syntax.
To get a grasp of how it works, it is better to just look at the program examples.


===============================================================

File extension:
Chespel source files have the extension .chp

===============================================================

Compilation:

Compiling a Chespel program can give three possible outputs:

1. (no flags)	A "stand alone" executable, which can be run and will evaluate positions and play games.
2. (flag -e)	A standarized chess engine which uses the XBoard API .
3. (flag -s)	The C++ compiled source code. This is useful mostly for debugging purposes. Compiling this source gives the executable from point 1.

===============================================================

Stand alone executable:

After running the executable, it will wait for user input.
It accepts 4 kinds of input:
> {FEN record}
Shows:
- an ascii representation of the board
- the board punctuation (according to its eval function) for whoever moves next
- the FEN record of the board after making a move
- the ascii representation of the new board
- the new board punctuation (for the player who had to move)

> fen {FEN record}
Shows:
- the FEN record of the board after making a move

> eval [v] {FEN record}
Shows:
- an ascii representation of the board
- the board punctuation (according to its eval function) for whoever moves next
- if the option v (verbose) is added, it also prints a justification of the punctuation

> play
- it will enter play mode


===============================================================

Play mode:
- the user is asked whether the white player will be the AI or human.
- the user is asked whether the black player will be the AI or human.
- whenever it is time for a human to move, the program waits for a position in algebraic notation to be input.
if the user inputs 'l' instead, a list with the valid moves is shown.
- whenever it is time for the AI to move, the program will show:
	- an ascii representation of the board
	- the board punctuation (according to its eval function) for whoever moves next
	- the FEN record of the board after making a move
	- the ascii representation of the new board
	- the new board punctuation (for the player who had to move)

===============================================================


Modules:

The program is divided in modules.
Each module begins with keyword 'module' followed by the module name.
It extends until next 'module' keyword or end of file.
They can appear in any order.
The modules are predefined:
	- search		(optional)
	- evaluation	(mandatory)
	- opening		(optional)
	- endgame		(optional)
Each module has its own syntax particularities.

===============================================================


Comments:

C++ alike

Single line:
//
Extends to the end of the line
Multiline:
/* ... */


===============================================================

Module search:

This module defines different parameters to finetune the search algorithm.
If a given parameter is not specified, a default value is used.
Therefore, this module is optional.

Parameters:
- maxTime: limit in seconds of the search time for each move (default: 4)
Syntax:
maxTime = num

Advanced features:
Allowing the user to somehow use heuristics during the search to guide the search
(for example, sorting positions according to 'potential', to increase chance of trimming the search tree)

===============================================================

Module opening:

This module defines predefined replies to concrete situations.
Each instruction specifies a move.
The syntax is:
'{original position FEN record}' -> '{destination position FEN record}';
If the destination position is not a valid next move from the original position, a run-time error is thrown.
If the current position does not match the original position of any rule, the search algorithm is used instead.

Example:

//If the AI is white, start moving the king pawn to e4
'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1' ->
	'rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b KQkq e3 0 1';


Advanced features:
Allow the user to specify openings by name, such as the "Sicilian Defense" or the "Ruy Lopez".


===============================================================
Module evaluation

This is the main module, and the one that look "more" like
a programming language

The purpose of this module, is, given a board position,
make an estimation of the 'benignity' of the position for the user's player
This estimation is materialized in the 'score' value.
In other words, this module is a function that maps board positions to scores.

This module is made of a set of rules.
The score is initialized to 0.
Each rule modifies the score (potentially).
The result of evaluating the board is the value of the score after applying each rule.

===============================================================

Types:

See TypeSystemSpecification.txt


===============================================================

Functions:

See functions.txt

===============================================================

Code blocks:

A code block is a sequence of consecutive statements.
They start after a statement ending in colon (:) (called the opening statement)
Opening statements: rule declarations, ifs and loops.
All statements of the code block must be tabulated one tab further than the opening statement.

A variable defined within a code block is visible from the declaration point until the end of the block.

Code blocks have recursive nature:


Examples:

	sym rule knightSimbiosis:
		piece n1, n2 with n1.player == me, n2.player == me:
			let cellList = n1.visibleCells;
			if (n2.pos in cellList) score 0.2;

The 'let' and 'if' statements belong to the block opened by the 'piece' loop.


	rule check:
		if (me.check):
			score -5;

The 'score' statement belongs to the 'if' block, which in turn belongs to the 'rule' block.


===============================================================
Score:

The score is a global variable of type num.
When a board is a winning position, the score is automatically set to 10000
When a board is a losing position, the score is automatically set to -10000

Otherwise, the user has to program rules that set the score to an appropiate value
using heuristics.

===============================================================

Rules:

A rule definition is a code block opened by a rule statement.

Syntax:

rule ruleName:
	statement1
	statement2
	...


'rule' may be preceded with the keyword 'sym' ('sym' for symmetry).
If this keyword is added, the rule is applied twice:
once normally and once reversing the score statements' values and the roles of the players.

For example: if the user's player has 3 pawn and the opponent has 2 pawns,
and we have a rule that adds one point to the score for each pawn,
the effect of applying the rule will be:
a) score = score + 3		(without sym keyword)
b) score = score + 3 - 2 	(with sym keyword)


===============================================================

Statements:

There is a limited number of statements:
- score
- if
- let
- loop

===============================================================

Score statement:

Modifies the value of the score.

Syntax:
score {num};
Meaning:
score = score + num

Examples:
score 2;
score -0.1;
score p.value;


Alternative syntax:

score {num}, {string};
In this case, the string is the justification.
This will allow the user to see the reasoning behind the scoring of a board position.


===============================================================

Justification:
Justifications are used in the stand alone executable, when the 'eval' input
is used with the verbose (v) option.
Each time a 'score' statement is encountered, its corresponding justification
string is added with the following format:
"rule_name: " {num} {justification_string}
If there is no justification string, that field will be empty.

Example rule

	rule check:
		if (me.check()):
			score -5, "under check";

Example output:
"check: -5 under check"

In case, the rule is symmetric, the player for which the rule was triggering is added at the begin:

Example: a symmetric rule increases the score in 2 point for castling king side and 1 queen side:

" ...
me:    castling: +2 castled king side
foe:   castling: -1 castled queen side
... "

Before printing the justification to the user, justification strings which look exactly the same
(including the rule name) are mashed together. Example:
"rule_name: " {num*number_of_times} {justification_string} ({number_of_times})

Example rule

	sym rule doubledPawns:
		piece p1, p2 with p1.player == me, p2.player == me,
						  p1.type == pawn, p2.type == pawn:
			if (p1.col == p2.col) score -0.3;

" ...
me:    doubledPawns: -0.9 (3)
foe:   doubledPawns: -0.3
... "


===============================================================

if statement:

Executes a block of code if a condition holds.

Syntax:
if (boolean_condition):
	statement1
	statement2
	...

Example

	sym rule castling:
		if (me.castled()):
			score 1;


If an if statement block contains a singular score statement, it can be written inline:
if (boolean_condition) score {num};

But it is just syntax sugar for:
if (boolean_condition):
	score {num};

example

	sym rule check:
		if (me.check()) score -5;


===============================================================


Let statement:

Binds a value to a variable.

Syntax:
let variable_name = {value};

It is not necessary to specify the type.
The scope of the variable is the block of code (delimited by tabulation)
from the point at which it was declared.

===============================================================

Loop statement:
A loop has one or more loop variables. The loop variables have the same type.
A loop opens a new code block, where the loop variables are visible.
A loop binds different values to the loop variables at each iteration.
There is an iteration for each possible different variable binding,
except bindings where two loop variables are equal.

Syntax:
{loop_variables_class} {loop_variable_list} with {boolean_condition_list}:

loop_variable_list:
{loop_variable_1_name}, {loop_variable_2_name}, ... {loop_variable_n_name}

boolean_condition_list:
{boolean_condition_1, boolean_condition_2, ... boolean_condition_k}

Examples:

piece p1, p2 with p1.player == me, p2.player == me,
				  p1.type == pawn, p2.type == pawn:
	...


For each combination of different pawns of the user's player, this
loop executes its associated code block once, with the pawns binded to p1 and p2.

There can be line breaks between variable names or between boolean conditions.

Note: if there is a single variable loop,
it is not necessary to explicit the variable upon which the methods are called in the boolean codition list.


