This file tries to give some formalism to the syntax.
To get a grasp of how it works, it is better to just look at the program examples.


===============================================================

File extension:
Chespel source files have the extension .chp

===============================================================

Compilation:

Compiling a Chespel program can give three possible outputs:

1. (no flags)	A "stand alone" executable, which can be run and will evaluate positions and play games.
2. (flag -e)	A standarized chess engine which uses the XBoard API .
3. (flag -s)	The C++ compiled source code. This is useful mostly for debugging purposes. Compiling this source gives the executable from point 1.

===============================================================

Stand alone executable:

After running the executable, it will wait for user input.
It accepts 4 kinds of input:
> {FEN record}
Shows:
- an ascii representation of the board
- the board punctuation (according to its eval function) for whoever moves next
- the FEN record of the board after making a move
- the ascii representation of the new board
- the new board punctuation (for the player who had to move)

> fen {FEN record}
Shows:
- the FEN record of the board after making a move

> eval [v] {FEN record}
Shows:
- an ascii representation of the board
- the board punctuation (according to its eval function) for whoever moves next
- if the option v (verbose) is added, it also prints a justification of the punctuation

> play
- it will enter play mode


===============================================================

Play mode:
- the user is asked whether the white player will be the AI or human.
- the user is asked whether the black player will be the AI or human.
- whenever it is time for a human to move, the program waits for a position in algebraic notation to be input.
if the user inputs 'l' instead, a list with the valid moves is shown.
- whenever it is time for the AI to move, the program will show:
	- an ascii representation of the board
	- the board punctuation (according to its eval function) for whoever moves next
	- the FEN record of the board after making a move
	- the ascii representation of the new board
	- the new board punctuation (for the player who had to move)

===============================================================


Modules:

The program is divided in modules.
Each module begins with keyword 'module' followed by the module name.
It extends until next 'module' keyword or end of file.
They can appear in any order.
The modules are predefined:
	- search		(optional)
	- evaluation	(mandatory)
	- opening		(optional)
	- endgame		(optional)
Each module has its own syntax particularities.

===============================================================


Comments:

C++ alike

Single line:
//
Extends to the end of the line
Multiline:
/* ... */


===============================================================

Module search:

This module defines different parameters to finetune the search algorithm.
If a given parameter is not specified, a default value is used.
Therefore, this module is optional.

Parameters:
- maxTime: limit in seconds of the search time for each move (default: 4)
Syntax:
maxTime = num

Advanced features:
Allowing the user to somehow use heuristics during the search to guide the search
(for example, sorting positions according to 'potential', to increase chance of trimming the search tree)

===============================================================

Module opening:

This module defines predefined replies to concrete situations.
Each instruction specifies a move.
The syntax is:
'{original position FEN record}' -> '{destination position FEN record}';
If the destination position is not a valid next move from the original position, a run-time error is thrown.
If the current position does not match the original position of any rule, the search algorithm is used instead.

Example:

//If the AI is white, start moving the king pawn to e4
'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1' ->
	'rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b KQkq e3 0 1';


Advanced features:
Allow the user to specify openings by name, such as the "Sicilian Defense" or the "Ruy Lopez".


===============================================================
Module evaluation

This is the main module, and the one that look "more" like
a programming language

The purpose of this module, is, given a board position,
make an estimation of the 'benignity' of the position for the user's player
This estimation is materialized in the 'score' value.
In other words, this module is a function that maps board positions to scores.

This module is made of a set of rules.
The score is initialized to 0.
Each rule modifies the score (potentially).
The result of evaluating the board is the value of the score after applying each rule.

===============================================================

Types:

See typeSystem.txt


===============================================================

Functions:

Functions or methods are used by instances of classes.
An instance can use methods of its class and,
in case of aggregate classes, methods of the classes of its components.

A function is invoked by placing '.' after an instance and the function name.
If it takes one or more parameters, they are surrounded by parentheses and separated by commas.
If a function takes no parameters, parentheses are not used.

Functions do not have side effects. They don't modify the instance that invokes them.
They return instances of a certain class (known as the return type).
As parameters, they can take textual representation of instances or method calls that return an instance of the required type, including operators.

Existing functions can not be modified, and no new functions can be added.



===============================================================

Operators

Operators are similar to methods.
Instead of being used by instances, they take instances as parameters.

They take 2 parameters and have infix notation.
Exceptions: not and abs, which take one parameter and have infix notation.

They might be defined for more than one type, but it can't have parameters of different types.
Exception: in takes an instance of any class (except String and List) as first parameter and a list
of instances of the same type as second parameter.

If an operator expects a Num as parameter ann receives an instance of another type:
- if the type has a numerical value, the numerical value is used.
- otherwise, an error is thrown

If an operator expects a String as parameter and receives an instance of another type, the string representation is used.

Operators have an inherent priority. It can always be modified using parentheses.
List of operators (sorted by priority):

Operator 	Return class 	Parameters' classes
*			Num 			Num
/			Num 			Num
+			Num 			Num
-			Num 			Num
> 			Bool			Num
< 			Bool			Num
>=			Bool			Num
<=			Bool			Num
*<			Bool			Row
*>			Bool			Row
*<=			Bool			Row
*>=			Bool			Row
==			Bool			All except String and List
!=			Bool			All except String and List
abs 		Num 			Num
in 			Bool 			All except String and List & List of the same type
and 		Bool			Bool
or  		Bool			Bool
not 		Bool			Bool
++ 			Same as params.	String and List


Operators semantics:
Operators have their expected semantic.
== and != return whether two instances are the same or are different respectively.
in returns whether an instance is contained in a list of instances.
++ concatenates strings or lists:

The strings are concatenated by merging them all in a single string, in order.

Examples: notice how the string representation of types are used

let str1 = "own strategic cell " ++ p.cell.pos ++ " with a " ++ p.type;
	(str1 = "own strategic cell d4 with a knight")
let str2 = knight ++ true ++ 4.0 ++ 3+7 ++ pawn == knight;
	(str2 = "knighttrue410false")



===============================================================

Code blocks:

A code block is a sequence of consecutive statements.
They start after a statement ending in colon (:) (called the opening statement)
Opening statements: rule declarations, ifs and loops.
All statements of the code block must be tabulated one tab further than the opening statement.

A variable defined within a code block is visible from the declaration point until the end of the block.

Code blocks have recursive nature:


Examples:

	sym rule knightSimbiosis:
		piece n1, n2 with n1.player == me, n2.player == me:
			let cellList = n1.visibleCells;
			if n2.pos in cellList score 0.2;

The 'let' and 'if' statements belong to the block opened by the 'piece' loop.


	rule check:
		if me.check:
			score -5;

The 'score' statement belongs to the 'if' block, which in turn belongs to the 'rule' block.


===============================================================
Score:

The score is a global variable of type num.
When a board is a winning position, the score is automatically set to 10000
When a board is a losing position, the score is automatically set to -10000

Otherwise, the user has to program rules that set the score to an appropiate value
using heuristics.

===============================================================

Rules:

A rule definition is a code block opened by a rule statement.

Syntax:

rule ruleName:
	statement1
	statement2
	...


'rule' may be preceded with the keyword 'sym' ('sym' for symmetry).
If this keyword is added, the rule is applied twice:
once normally and once reversing the score statements' values and the roles of the players.

For example: if the user's player has 3 pawn and the opponent has 2 pawns,
and we have a rule that adds one point to the score for each pawn,
the effect of applying the rule will be:
a) score = score + 3		(without sym keyword)
b) score = score + 3 - 2 	(with sym keyword)


===============================================================

Statements:

There is a limited number of statements:
- score
- if
- let
- loop

Statements end in ;
In the future, this restriction could be removed.
===============================================================

Score statement:

Modifies the value of the score.

Syntax:
score {num};
Meaning:
score = score + num

Examples:
score 2;
score -0.1;
score p.value;


Alternative syntax:

score {num}, {string};
In this case, the string is the justification.
This will allow the user to see the reasoning behind the scoring of a board position.


===============================================================

Justification:
Justifications are used in the stand alone executable, when the 'eval' input
is used with the verbose (v) option.
Each time a 'score' statement is encountered, its corresponding justification
string is added with the following format:
"rule_name: " {num} {justification_string}
If there is no justification string, that field will be empty.

Example rule

	rule check:
		if me.check:
			score -5, "under check";

Example output:
"check: -5 under check"

In case, the rule is symmetric, the player for which the rule was triggering is added at the begin:

Example: a symmetric rule increases the score in 2 point for castling king side and 1 queen side:

" ...
me:    castling: +2 castled king side
foe:   castling: -1 castled queen side
... "

Before printing the justification to the user, justification strings which look exactly the same
(including the rule name) are mashed together. Example:
"rule_name: " {num*number_of_times} {justification_string} ({number_of_times})

Example rule

	sym rule doubledPawns:
		piece p1, p2 with p1.player == me, p2.player == me,
						  p1.type == pawn, p2.type == pawn:
			if p1.col == p2.col score -0.3;

" ...
me:    doubledPawns: -0.9 (3)
foe:   doubledPawns: -0.3
... "


===============================================================

if statement:

Executes a block of code if a condition holds.

Syntax:
if boolean_condition:
	statement1
	statement2
	...

Example

	sym rule castling:
		if me.castled:
			score 1;


If an if statement block contains a singular score statement, it can be written inline:
if boolean_condition score {num};

But it is just syntax sugar for:
if boolean_condition:
	score {num};

example

	sym rule check:
		if me.check score -5;


===============================================================


Let statement:

Binds a value to a variable.

Syntax:
let variable_name = {value};

It is not necessary to specify the type.
The scope of the variable is the block of code (delimited by tabulation)
from the point at which it was declared.

===============================================================

Loop statement:
A loop has one or more loop variables. The loop variables have the same type.
A loop opens a new code block, where the loop variables are visible.
A loop binds different values to the loop variables at each iteration.
There is an iteration for each possible different variable binding,
except bindings where two loop variables are equal.

Syntax:
{loop_variables_class} {loop_variable_list} with {boolean_condition_list}:

loop_variable_list:
{loop_variable_1_name}, {loop_variable_2_name}, ... {loop_variable_n_name}

boolean_condition_list:
{boolean_condition_1, boolean_condition_2, ... boolean_condition_k}

Examples:

piece p1, p2 with p1.player == me, p2.player == me,
				  p1.type == pawn, p2.type == pawn:
	...


For each combination of different pawns of the user's player, this
loop executes its associated code block once, with the pawns binded to p1 and p2.

There can be line breaks between variable names or between boolean conditions.

Note: if there is a single variable loop,
it is not necessary to explicit the variable upon which the methods are called in the boolean codition list.


