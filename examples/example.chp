/*
serious example that considers the most
relevant aspects of board evaluation.
we expect the corresponding chess engine
to be a strong player.

Several rules are repeated and implemented in different
ways. This shows the several ways to accomplish the
same thing in Chespel
*/

config {
    centipawn_value = 0.01;
}

global num checkPenalty = -0.6;
global num castlingBonus = -0.5 * checkPenalty;

num inc1(num n) {
	return n+1;
}

// value of my pieces minus value of opponent pieces
rule totalPieceValue sym  {
	forall (p in spieces) score p.value;
}

// 0.4 point for dominating each of the 4 central squares
rule centerDomination sym  {
	forall (p in spieces) {
		if (p.row in [$4, $5] and p.file in [$d,$e]) score 0.4;
	}
}

// 0.5 point for castling
rule castling sym, opening, midgame  {
	if (self.castled) score castlingBonus;
}

// common functions like abs() will be built-in
num abs(num n) {
	if (n < 0) return -n;
	return n;
}

// 0.1 points for each pawn advancement
rule forwardPawnLine sym,opening  {
	forall (p in spawns)
		score abs(p.row - p.startingRow) * 0.1;
}

// -0.3 point for each non-covered piece
rule nonCovered sym  {
	forall (p in spieces)
		if (p.coveredBy == []) score -0.3;
}

//example using check syntax
// -0.6 points if check
rule notChecked sym  
  do if self.check
{
		score checkPenalty;
}

// -0.3 for doubled pawns
rule doubledPawns sym  {
	forall (p1 in spawns) {
		forall (p2 in spawns) {
			if (p1.row < p2.row and p1.file == p2.file)
				score -0.3;
		}
	}
}

// +0.2 if knights cover each other
rule knightSimbiosis sym {
	forall (n1 in sknights) {
		forall (n2 in sknights) {
			[cell] L = n1.visibleCells;
			forall (c in L) {
				if (n2.cell == c) score 0.2;
			}
		}
	}
}

//example recursive function: not used in the evaluation function

// A stronglyProtected piece is a piece which is covered and the pieces
// covering it are also stronglyProtected
bool stronglyProtected(piece p) {
 [piece] visited = [p];
 return stronglyProtectedAux(p, visited); 
}

bool stronglyProtectedAux(piece p, [piece] & visited) {
   //let L be the list of pieces covering p
   [piece] L = [];
   forall (p2 in spieces)
     if (p.cell in p2.coveredCells) L = L ++ [p2];
   if (len(L) == 0) return false;
   
   forall (p2 in L) {
     if (not p2 in visited) {
       [piece] visited2 = visited ++ [p2];
       if (not stronglyProtectedAux(p2, visited2)) return false;
       visited = visited ++ [p2] ;
     }
   }
   return true;
}
